package px4_msgs.msg.dds;

import us.ihmc.communication.packets.Packet;
import us.ihmc.euclid.interfaces.Settable;
import us.ihmc.euclid.interfaces.EpsilonComparable;
import java.util.function.Supplier;
import us.ihmc.pubsub.TopicDataType;

/**
       * Fused local position in NED.
       * The coordinate system origin is the vehicle position at the time when the EKF2-module was started.
       */
public class VehicleLocalPosition extends Packet<VehicleLocalPosition> implements Settable<VehicleLocalPosition>, EpsilonComparable<VehicleLocalPosition>
{
   public static final byte DIST_BOTTOM_SENSOR_NONE = (byte) 0;
   /**
          * (1 << 0) a range sensor is used to estimate dist_bottom field
          */
   public static final byte DIST_BOTTOM_SENSOR_RANGE = (byte) 1;
   /**
          * (1 << 1) a flow sensor is used to estimate dist_bottom field (mostly fixed-wing use case)
          */
   public static final byte DIST_BOTTOM_SENSOR_FLOW = (byte) 2;
   /**
            * time since system start (microseconds)
            */
   public long timestamp_;
   /**
            * the timestamp of the raw data (microseconds)
            */
   public long timestamp_sample_;
   /**
            * true if x and y are valid
            */
   public boolean xy_valid_;
   /**
            * true if z is valid
            */
   public boolean z_valid_;
   /**
            * true if vx and vy are valid
            */
   public boolean v_xy_valid_;
   /**
            * true if vz is valid
            */
   public boolean v_z_valid_;
   /**
            * Position in local NED frame
            * North position in NED earth-fixed frame, (metres)
            */
   public float x_;
   /**
            * East position in NED earth-fixed frame, (metres)
            */
   public float y_;
   /**
            * Down position (negative altitude) in NED earth-fixed frame, (metres)
            */
   public float z_;
   /**
            * Position reset delta
            * Amount of lateral shift of position estimate in latest reset (in x and y) [m]
            */
   public float[] delta_xy_;
   /**
            * Index of latest lateral position estimate reset
            */
   public byte xy_reset_counter_;
   /**
            * Amount of vertical shift of position estimate in latest reset [m]
            */
   public float delta_z_;
   /**
            * Index of latest vertical position estimate reset
            */
   public byte z_reset_counter_;
   /**
            * Velocity in NED frame
            * North velocity in NED earth-fixed frame, (metres/sec)
            */
   public float vx_;
   /**
            * East velocity in NED earth-fixed frame, (metres/sec)
            */
   public float vy_;
   /**
            * Down velocity in NED earth-fixed frame, (metres/sec)
            */
   public float vz_;
   /**
            * Down position time derivative in NED earth-fixed frame, (metres/sec)
            */
   public float z_deriv_;
   /**
            * Velocity reset delta
            * Amount of lateral shift of velocity estimate in latest reset (in x and y) [m/s]
            */
   public float[] delta_vxy_;
   /**
            * Index of latest vertical velocity estimate reset
            */
   public byte vxy_reset_counter_;
   /**
            * Amount of vertical shift of velocity estimate in latest reset [m/s]
            */
   public float delta_vz_;
   /**
            * Index of latest vertical velocity estimate reset
            */
   public byte vz_reset_counter_;
   /**
            * Acceleration in NED frame
            * North velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public float ax_;
   /**
            * East velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public float ay_;
   /**
            * Down velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public float az_;
   /**
            * Euler yaw angle transforming the tangent plane relative to NED earth-fixed frame, -PI..+PI,  (radians)
            */
   public float heading_;
   public float heading_var_;
   /**
            * Same as heading but generated by integrating corrected gyro data only
            */
   public float unaided_heading_;
   /**
            * Heading delta caused by latest heading reset [rad]
            */
   public float delta_heading_;
   /**
            * Index of latest heading reset
            */
   public byte heading_reset_counter_;
   public boolean heading_good_for_control_;
   public float tilt_var_;
   /**
            * Position of reference point (local NED frame origin) in global (GPS / WGS84) frame
            * true if position (x, y) has a valid global reference (ref_lat, ref_lon)
            */
   public boolean xy_global_;
   /**
            * true if z has a valid global reference (ref_alt)
            */
   public boolean z_global_;
   /**
            * Time when reference position was set since system start, (microseconds)
            */
   public long ref_timestamp_;
   /**
            * Reference point latitude, (degrees)
            */
   public double ref_lat_;
   /**
            * Reference point longitude, (degrees)
            */
   public double ref_lon_;
   /**
            * Reference altitude AMSL, (metres)
            */
   public float ref_alt_;
   /**
            * Distance to surface
            * true if distance to bottom surface is valid
            */
   public boolean dist_bottom_valid_;
   /**
            * Distance from from bottom surface to ground, (metres)
            */
   public float dist_bottom_;
   /**
            * terrain estimate variance (m^2)
            */
   public float dist_bottom_var_;
   /**
            * Amount of vertical shift of dist bottom estimate in latest reset [m]
            */
   public float delta_dist_bottom_;
   /**
            * Index of latest dist bottom estimate reset
            */
   public byte dist_bottom_reset_counter_;
   /**
            * bitfield indicating what type of sensor is used to estimate dist_bottom
            */
   public byte dist_bottom_sensor_bitfield_;
   /**
            * Standard deviation of horizontal position error, (metres)
            */
   public float eph_;
   /**
            * Standard deviation of vertical position error, (metres)
            */
   public float epv_;
   /**
            * Standard deviation of horizontal velocity error, (metres/sec)
            */
   public float evh_;
   /**
            * Standard deviation of vertical velocity error, (metres/sec)
            */
   public float evv_;
   /**
            * True if this position is estimated through dead-reckoning
            */
   public boolean dead_reckoning_;
   /**
            * estimator specified vehicle limits
            * maximum horizontal speed - set to 0 when limiting not required (meters/sec)
            */
   public float vxy_max_;
   /**
            * maximum vertical speed - set to 0 when limiting not required (meters/sec)
            */
   public float vz_max_;
   /**
            * minimum height above ground level - set to 0 when limiting not required (meters)
            */
   public float hagl_min_;
   /**
            * maximum height above ground level - set to 0 when limiting not required (meters)
            */
   public float hagl_max_;

   public VehicleLocalPosition()
   {
      delta_xy_ = new float[2];

      delta_vxy_ = new float[2];

   }

   public VehicleLocalPosition(VehicleLocalPosition other)
   {
      this();
      set(other);
   }

   public void set(VehicleLocalPosition other)
   {
      timestamp_ = other.timestamp_;

      timestamp_sample_ = other.timestamp_sample_;

      xy_valid_ = other.xy_valid_;

      z_valid_ = other.z_valid_;

      v_xy_valid_ = other.v_xy_valid_;

      v_z_valid_ = other.v_z_valid_;

      x_ = other.x_;

      y_ = other.y_;

      z_ = other.z_;

      for(int i1 = 0; i1 < delta_xy_.length; ++i1)
      {
            delta_xy_[i1] = other.delta_xy_[i1];

      }

      xy_reset_counter_ = other.xy_reset_counter_;

      delta_z_ = other.delta_z_;

      z_reset_counter_ = other.z_reset_counter_;

      vx_ = other.vx_;

      vy_ = other.vy_;

      vz_ = other.vz_;

      z_deriv_ = other.z_deriv_;

      for(int i3 = 0; i3 < delta_vxy_.length; ++i3)
      {
            delta_vxy_[i3] = other.delta_vxy_[i3];

      }

      vxy_reset_counter_ = other.vxy_reset_counter_;

      delta_vz_ = other.delta_vz_;

      vz_reset_counter_ = other.vz_reset_counter_;

      ax_ = other.ax_;

      ay_ = other.ay_;

      az_ = other.az_;

      heading_ = other.heading_;

      heading_var_ = other.heading_var_;

      unaided_heading_ = other.unaided_heading_;

      delta_heading_ = other.delta_heading_;

      heading_reset_counter_ = other.heading_reset_counter_;

      heading_good_for_control_ = other.heading_good_for_control_;

      tilt_var_ = other.tilt_var_;

      xy_global_ = other.xy_global_;

      z_global_ = other.z_global_;

      ref_timestamp_ = other.ref_timestamp_;

      ref_lat_ = other.ref_lat_;

      ref_lon_ = other.ref_lon_;

      ref_alt_ = other.ref_alt_;

      dist_bottom_valid_ = other.dist_bottom_valid_;

      dist_bottom_ = other.dist_bottom_;

      dist_bottom_var_ = other.dist_bottom_var_;

      delta_dist_bottom_ = other.delta_dist_bottom_;

      dist_bottom_reset_counter_ = other.dist_bottom_reset_counter_;

      dist_bottom_sensor_bitfield_ = other.dist_bottom_sensor_bitfield_;

      eph_ = other.eph_;

      epv_ = other.epv_;

      evh_ = other.evh_;

      evv_ = other.evv_;

      dead_reckoning_ = other.dead_reckoning_;

      vxy_max_ = other.vxy_max_;

      vz_max_ = other.vz_max_;

      hagl_min_ = other.hagl_min_;

      hagl_max_ = other.hagl_max_;

   }

   /**
            * time since system start (microseconds)
            */
   public void setTimestamp(long timestamp)
   {
      timestamp_ = timestamp;
   }
   /**
            * time since system start (microseconds)
            */
   public long getTimestamp()
   {
      return timestamp_;
   }

   /**
            * the timestamp of the raw data (microseconds)
            */
   public void setTimestampSample(long timestamp_sample)
   {
      timestamp_sample_ = timestamp_sample;
   }
   /**
            * the timestamp of the raw data (microseconds)
            */
   public long getTimestampSample()
   {
      return timestamp_sample_;
   }

   /**
            * true if x and y are valid
            */
   public void setXyValid(boolean xy_valid)
   {
      xy_valid_ = xy_valid;
   }
   /**
            * true if x and y are valid
            */
   public boolean getXyValid()
   {
      return xy_valid_;
   }

   /**
            * true if z is valid
            */
   public void setZValid(boolean z_valid)
   {
      z_valid_ = z_valid;
   }
   /**
            * true if z is valid
            */
   public boolean getZValid()
   {
      return z_valid_;
   }

   /**
            * true if vx and vy are valid
            */
   public void setVXyValid(boolean v_xy_valid)
   {
      v_xy_valid_ = v_xy_valid;
   }
   /**
            * true if vx and vy are valid
            */
   public boolean getVXyValid()
   {
      return v_xy_valid_;
   }

   /**
            * true if vz is valid
            */
   public void setVZValid(boolean v_z_valid)
   {
      v_z_valid_ = v_z_valid;
   }
   /**
            * true if vz is valid
            */
   public boolean getVZValid()
   {
      return v_z_valid_;
   }

   /**
            * Position in local NED frame
            * North position in NED earth-fixed frame, (metres)
            */
   public void setX(float x)
   {
      x_ = x;
   }
   /**
            * Position in local NED frame
            * North position in NED earth-fixed frame, (metres)
            */
   public float getX()
   {
      return x_;
   }

   /**
            * East position in NED earth-fixed frame, (metres)
            */
   public void setY(float y)
   {
      y_ = y;
   }
   /**
            * East position in NED earth-fixed frame, (metres)
            */
   public float getY()
   {
      return y_;
   }

   /**
            * Down position (negative altitude) in NED earth-fixed frame, (metres)
            */
   public void setZ(float z)
   {
      z_ = z;
   }
   /**
            * Down position (negative altitude) in NED earth-fixed frame, (metres)
            */
   public float getZ()
   {
      return z_;
   }


   /**
            * Position reset delta
            * Amount of lateral shift of position estimate in latest reset (in x and y) [m]
            */
   public float[] getDeltaXy()
   {
      return delta_xy_;
   }

   /**
            * Index of latest lateral position estimate reset
            */
   public void setXyResetCounter(byte xy_reset_counter)
   {
      xy_reset_counter_ = xy_reset_counter;
   }
   /**
            * Index of latest lateral position estimate reset
            */
   public byte getXyResetCounter()
   {
      return xy_reset_counter_;
   }

   /**
            * Amount of vertical shift of position estimate in latest reset [m]
            */
   public void setDeltaZ(float delta_z)
   {
      delta_z_ = delta_z;
   }
   /**
            * Amount of vertical shift of position estimate in latest reset [m]
            */
   public float getDeltaZ()
   {
      return delta_z_;
   }

   /**
            * Index of latest vertical position estimate reset
            */
   public void setZResetCounter(byte z_reset_counter)
   {
      z_reset_counter_ = z_reset_counter;
   }
   /**
            * Index of latest vertical position estimate reset
            */
   public byte getZResetCounter()
   {
      return z_reset_counter_;
   }

   /**
            * Velocity in NED frame
            * North velocity in NED earth-fixed frame, (metres/sec)
            */
   public void setVx(float vx)
   {
      vx_ = vx;
   }
   /**
            * Velocity in NED frame
            * North velocity in NED earth-fixed frame, (metres/sec)
            */
   public float getVx()
   {
      return vx_;
   }

   /**
            * East velocity in NED earth-fixed frame, (metres/sec)
            */
   public void setVy(float vy)
   {
      vy_ = vy;
   }
   /**
            * East velocity in NED earth-fixed frame, (metres/sec)
            */
   public float getVy()
   {
      return vy_;
   }

   /**
            * Down velocity in NED earth-fixed frame, (metres/sec)
            */
   public void setVz(float vz)
   {
      vz_ = vz;
   }
   /**
            * Down velocity in NED earth-fixed frame, (metres/sec)
            */
   public float getVz()
   {
      return vz_;
   }

   /**
            * Down position time derivative in NED earth-fixed frame, (metres/sec)
            */
   public void setZDeriv(float z_deriv)
   {
      z_deriv_ = z_deriv;
   }
   /**
            * Down position time derivative in NED earth-fixed frame, (metres/sec)
            */
   public float getZDeriv()
   {
      return z_deriv_;
   }


   /**
            * Velocity reset delta
            * Amount of lateral shift of velocity estimate in latest reset (in x and y) [m/s]
            */
   public float[] getDeltaVxy()
   {
      return delta_vxy_;
   }

   /**
            * Index of latest vertical velocity estimate reset
            */
   public void setVxyResetCounter(byte vxy_reset_counter)
   {
      vxy_reset_counter_ = vxy_reset_counter;
   }
   /**
            * Index of latest vertical velocity estimate reset
            */
   public byte getVxyResetCounter()
   {
      return vxy_reset_counter_;
   }

   /**
            * Amount of vertical shift of velocity estimate in latest reset [m/s]
            */
   public void setDeltaVz(float delta_vz)
   {
      delta_vz_ = delta_vz;
   }
   /**
            * Amount of vertical shift of velocity estimate in latest reset [m/s]
            */
   public float getDeltaVz()
   {
      return delta_vz_;
   }

   /**
            * Index of latest vertical velocity estimate reset
            */
   public void setVzResetCounter(byte vz_reset_counter)
   {
      vz_reset_counter_ = vz_reset_counter;
   }
   /**
            * Index of latest vertical velocity estimate reset
            */
   public byte getVzResetCounter()
   {
      return vz_reset_counter_;
   }

   /**
            * Acceleration in NED frame
            * North velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public void setAx(float ax)
   {
      ax_ = ax;
   }
   /**
            * Acceleration in NED frame
            * North velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public float getAx()
   {
      return ax_;
   }

   /**
            * East velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public void setAy(float ay)
   {
      ay_ = ay;
   }
   /**
            * East velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public float getAy()
   {
      return ay_;
   }

   /**
            * Down velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public void setAz(float az)
   {
      az_ = az;
   }
   /**
            * Down velocity derivative in NED earth-fixed frame, (metres/sec^2)
            */
   public float getAz()
   {
      return az_;
   }

   /**
            * Euler yaw angle transforming the tangent plane relative to NED earth-fixed frame, -PI..+PI,  (radians)
            */
   public void setHeading(float heading)
   {
      heading_ = heading;
   }
   /**
            * Euler yaw angle transforming the tangent plane relative to NED earth-fixed frame, -PI..+PI,  (radians)
            */
   public float getHeading()
   {
      return heading_;
   }

   public void setHeadingVar(float heading_var)
   {
      heading_var_ = heading_var;
   }
   public float getHeadingVar()
   {
      return heading_var_;
   }

   /**
            * Same as heading but generated by integrating corrected gyro data only
            */
   public void setUnaidedHeading(float unaided_heading)
   {
      unaided_heading_ = unaided_heading;
   }
   /**
            * Same as heading but generated by integrating corrected gyro data only
            */
   public float getUnaidedHeading()
   {
      return unaided_heading_;
   }

   /**
            * Heading delta caused by latest heading reset [rad]
            */
   public void setDeltaHeading(float delta_heading)
   {
      delta_heading_ = delta_heading;
   }
   /**
            * Heading delta caused by latest heading reset [rad]
            */
   public float getDeltaHeading()
   {
      return delta_heading_;
   }

   /**
            * Index of latest heading reset
            */
   public void setHeadingResetCounter(byte heading_reset_counter)
   {
      heading_reset_counter_ = heading_reset_counter;
   }
   /**
            * Index of latest heading reset
            */
   public byte getHeadingResetCounter()
   {
      return heading_reset_counter_;
   }

   public void setHeadingGoodForControl(boolean heading_good_for_control)
   {
      heading_good_for_control_ = heading_good_for_control;
   }
   public boolean getHeadingGoodForControl()
   {
      return heading_good_for_control_;
   }

   public void setTiltVar(float tilt_var)
   {
      tilt_var_ = tilt_var;
   }
   public float getTiltVar()
   {
      return tilt_var_;
   }

   /**
            * Position of reference point (local NED frame origin) in global (GPS / WGS84) frame
            * true if position (x, y) has a valid global reference (ref_lat, ref_lon)
            */
   public void setXyGlobal(boolean xy_global)
   {
      xy_global_ = xy_global;
   }
   /**
            * Position of reference point (local NED frame origin) in global (GPS / WGS84) frame
            * true if position (x, y) has a valid global reference (ref_lat, ref_lon)
            */
   public boolean getXyGlobal()
   {
      return xy_global_;
   }

   /**
            * true if z has a valid global reference (ref_alt)
            */
   public void setZGlobal(boolean z_global)
   {
      z_global_ = z_global;
   }
   /**
            * true if z has a valid global reference (ref_alt)
            */
   public boolean getZGlobal()
   {
      return z_global_;
   }

   /**
            * Time when reference position was set since system start, (microseconds)
            */
   public void setRefTimestamp(long ref_timestamp)
   {
      ref_timestamp_ = ref_timestamp;
   }
   /**
            * Time when reference position was set since system start, (microseconds)
            */
   public long getRefTimestamp()
   {
      return ref_timestamp_;
   }

   /**
            * Reference point latitude, (degrees)
            */
   public void setRefLat(double ref_lat)
   {
      ref_lat_ = ref_lat;
   }
   /**
            * Reference point latitude, (degrees)
            */
   public double getRefLat()
   {
      return ref_lat_;
   }

   /**
            * Reference point longitude, (degrees)
            */
   public void setRefLon(double ref_lon)
   {
      ref_lon_ = ref_lon;
   }
   /**
            * Reference point longitude, (degrees)
            */
   public double getRefLon()
   {
      return ref_lon_;
   }

   /**
            * Reference altitude AMSL, (metres)
            */
   public void setRefAlt(float ref_alt)
   {
      ref_alt_ = ref_alt;
   }
   /**
            * Reference altitude AMSL, (metres)
            */
   public float getRefAlt()
   {
      return ref_alt_;
   }

   /**
            * Distance to surface
            * true if distance to bottom surface is valid
            */
   public void setDistBottomValid(boolean dist_bottom_valid)
   {
      dist_bottom_valid_ = dist_bottom_valid;
   }
   /**
            * Distance to surface
            * true if distance to bottom surface is valid
            */
   public boolean getDistBottomValid()
   {
      return dist_bottom_valid_;
   }

   /**
            * Distance from from bottom surface to ground, (metres)
            */
   public void setDistBottom(float dist_bottom)
   {
      dist_bottom_ = dist_bottom;
   }
   /**
            * Distance from from bottom surface to ground, (metres)
            */
   public float getDistBottom()
   {
      return dist_bottom_;
   }

   /**
            * terrain estimate variance (m^2)
            */
   public void setDistBottomVar(float dist_bottom_var)
   {
      dist_bottom_var_ = dist_bottom_var;
   }
   /**
            * terrain estimate variance (m^2)
            */
   public float getDistBottomVar()
   {
      return dist_bottom_var_;
   }

   /**
            * Amount of vertical shift of dist bottom estimate in latest reset [m]
            */
   public void setDeltaDistBottom(float delta_dist_bottom)
   {
      delta_dist_bottom_ = delta_dist_bottom;
   }
   /**
            * Amount of vertical shift of dist bottom estimate in latest reset [m]
            */
   public float getDeltaDistBottom()
   {
      return delta_dist_bottom_;
   }

   /**
            * Index of latest dist bottom estimate reset
            */
   public void setDistBottomResetCounter(byte dist_bottom_reset_counter)
   {
      dist_bottom_reset_counter_ = dist_bottom_reset_counter;
   }
   /**
            * Index of latest dist bottom estimate reset
            */
   public byte getDistBottomResetCounter()
   {
      return dist_bottom_reset_counter_;
   }

   /**
            * bitfield indicating what type of sensor is used to estimate dist_bottom
            */
   public void setDistBottomSensorBitfield(byte dist_bottom_sensor_bitfield)
   {
      dist_bottom_sensor_bitfield_ = dist_bottom_sensor_bitfield;
   }
   /**
            * bitfield indicating what type of sensor is used to estimate dist_bottom
            */
   public byte getDistBottomSensorBitfield()
   {
      return dist_bottom_sensor_bitfield_;
   }

   /**
            * Standard deviation of horizontal position error, (metres)
            */
   public void setEph(float eph)
   {
      eph_ = eph;
   }
   /**
            * Standard deviation of horizontal position error, (metres)
            */
   public float getEph()
   {
      return eph_;
   }

   /**
            * Standard deviation of vertical position error, (metres)
            */
   public void setEpv(float epv)
   {
      epv_ = epv;
   }
   /**
            * Standard deviation of vertical position error, (metres)
            */
   public float getEpv()
   {
      return epv_;
   }

   /**
            * Standard deviation of horizontal velocity error, (metres/sec)
            */
   public void setEvh(float evh)
   {
      evh_ = evh;
   }
   /**
            * Standard deviation of horizontal velocity error, (metres/sec)
            */
   public float getEvh()
   {
      return evh_;
   }

   /**
            * Standard deviation of vertical velocity error, (metres/sec)
            */
   public void setEvv(float evv)
   {
      evv_ = evv;
   }
   /**
            * Standard deviation of vertical velocity error, (metres/sec)
            */
   public float getEvv()
   {
      return evv_;
   }

   /**
            * True if this position is estimated through dead-reckoning
            */
   public void setDeadReckoning(boolean dead_reckoning)
   {
      dead_reckoning_ = dead_reckoning;
   }
   /**
            * True if this position is estimated through dead-reckoning
            */
   public boolean getDeadReckoning()
   {
      return dead_reckoning_;
   }

   /**
            * estimator specified vehicle limits
            * maximum horizontal speed - set to 0 when limiting not required (meters/sec)
            */
   public void setVxyMax(float vxy_max)
   {
      vxy_max_ = vxy_max;
   }
   /**
            * estimator specified vehicle limits
            * maximum horizontal speed - set to 0 when limiting not required (meters/sec)
            */
   public float getVxyMax()
   {
      return vxy_max_;
   }

   /**
            * maximum vertical speed - set to 0 when limiting not required (meters/sec)
            */
   public void setVzMax(float vz_max)
   {
      vz_max_ = vz_max;
   }
   /**
            * maximum vertical speed - set to 0 when limiting not required (meters/sec)
            */
   public float getVzMax()
   {
      return vz_max_;
   }

   /**
            * minimum height above ground level - set to 0 when limiting not required (meters)
            */
   public void setHaglMin(float hagl_min)
   {
      hagl_min_ = hagl_min;
   }
   /**
            * minimum height above ground level - set to 0 when limiting not required (meters)
            */
   public float getHaglMin()
   {
      return hagl_min_;
   }

   /**
            * maximum height above ground level - set to 0 when limiting not required (meters)
            */
   public void setHaglMax(float hagl_max)
   {
      hagl_max_ = hagl_max;
   }
   /**
            * maximum height above ground level - set to 0 when limiting not required (meters)
            */
   public float getHaglMax()
   {
      return hagl_max_;
   }


   public static Supplier<VehicleLocalPositionPubSubType> getPubSubType()
   {
      return VehicleLocalPositionPubSubType::new;
   }

   @Override
   public Supplier<TopicDataType> getPubSubTypePacket()
   {
      return VehicleLocalPositionPubSubType::new;
   }

   @Override
   public boolean epsilonEquals(VehicleLocalPosition other, double epsilon)
   {
      if(other == null) return false;
      if(other == this) return true;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.timestamp_, other.timestamp_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.timestamp_sample_, other.timestamp_sample_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.xy_valid_, other.xy_valid_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.z_valid_, other.z_valid_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.v_xy_valid_, other.v_xy_valid_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.v_z_valid_, other.v_z_valid_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.x_, other.x_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.y_, other.y_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.z_, other.z_, epsilon)) return false;

      for(int i5 = 0; i5 < delta_xy_.length; ++i5)
      {
                if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.delta_xy_[i5], other.delta_xy_[i5], epsilon)) return false;
      }

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.xy_reset_counter_, other.xy_reset_counter_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.delta_z_, other.delta_z_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.z_reset_counter_, other.z_reset_counter_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vx_, other.vx_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vy_, other.vy_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vz_, other.vz_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.z_deriv_, other.z_deriv_, epsilon)) return false;

      for(int i7 = 0; i7 < delta_vxy_.length; ++i7)
      {
                if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.delta_vxy_[i7], other.delta_vxy_[i7], epsilon)) return false;
      }

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vxy_reset_counter_, other.vxy_reset_counter_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.delta_vz_, other.delta_vz_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vz_reset_counter_, other.vz_reset_counter_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.ax_, other.ax_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.ay_, other.ay_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.az_, other.az_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.heading_, other.heading_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.heading_var_, other.heading_var_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.unaided_heading_, other.unaided_heading_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.delta_heading_, other.delta_heading_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.heading_reset_counter_, other.heading_reset_counter_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.heading_good_for_control_, other.heading_good_for_control_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.tilt_var_, other.tilt_var_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.xy_global_, other.xy_global_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.z_global_, other.z_global_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.ref_timestamp_, other.ref_timestamp_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.ref_lat_, other.ref_lat_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.ref_lon_, other.ref_lon_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.ref_alt_, other.ref_alt_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.dist_bottom_valid_, other.dist_bottom_valid_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.dist_bottom_, other.dist_bottom_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.dist_bottom_var_, other.dist_bottom_var_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.delta_dist_bottom_, other.delta_dist_bottom_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.dist_bottom_reset_counter_, other.dist_bottom_reset_counter_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.dist_bottom_sensor_bitfield_, other.dist_bottom_sensor_bitfield_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.eph_, other.eph_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.epv_, other.epv_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.evh_, other.evh_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.evv_, other.evv_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsBoolean(this.dead_reckoning_, other.dead_reckoning_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vxy_max_, other.vxy_max_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.vz_max_, other.vz_max_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.hagl_min_, other.hagl_min_, epsilon)) return false;

      if (!us.ihmc.idl.IDLTools.epsilonEqualsPrimitive(this.hagl_max_, other.hagl_max_, epsilon)) return false;


      return true;
   }

   @Override
   public boolean equals(Object other)
   {
      if(other == null) return false;
      if(other == this) return true;
      if(!(other instanceof VehicleLocalPosition)) return false;

      VehicleLocalPosition otherMyClass = (VehicleLocalPosition) other;

      if(this.timestamp_ != otherMyClass.timestamp_) return false;

      if(this.timestamp_sample_ != otherMyClass.timestamp_sample_) return false;

      if(this.xy_valid_ != otherMyClass.xy_valid_) return false;

      if(this.z_valid_ != otherMyClass.z_valid_) return false;

      if(this.v_xy_valid_ != otherMyClass.v_xy_valid_) return false;

      if(this.v_z_valid_ != otherMyClass.v_z_valid_) return false;

      if(this.x_ != otherMyClass.x_) return false;

      if(this.y_ != otherMyClass.y_) return false;

      if(this.z_ != otherMyClass.z_) return false;

      for(int i9 = 0; i9 < delta_xy_.length; ++i9)
      {
                if(this.delta_xy_[i9] != otherMyClass.delta_xy_[i9]) return false;

      }
      if(this.xy_reset_counter_ != otherMyClass.xy_reset_counter_) return false;

      if(this.delta_z_ != otherMyClass.delta_z_) return false;

      if(this.z_reset_counter_ != otherMyClass.z_reset_counter_) return false;

      if(this.vx_ != otherMyClass.vx_) return false;

      if(this.vy_ != otherMyClass.vy_) return false;

      if(this.vz_ != otherMyClass.vz_) return false;

      if(this.z_deriv_ != otherMyClass.z_deriv_) return false;

      for(int i11 = 0; i11 < delta_vxy_.length; ++i11)
      {
                if(this.delta_vxy_[i11] != otherMyClass.delta_vxy_[i11]) return false;

      }
      if(this.vxy_reset_counter_ != otherMyClass.vxy_reset_counter_) return false;

      if(this.delta_vz_ != otherMyClass.delta_vz_) return false;

      if(this.vz_reset_counter_ != otherMyClass.vz_reset_counter_) return false;

      if(this.ax_ != otherMyClass.ax_) return false;

      if(this.ay_ != otherMyClass.ay_) return false;

      if(this.az_ != otherMyClass.az_) return false;

      if(this.heading_ != otherMyClass.heading_) return false;

      if(this.heading_var_ != otherMyClass.heading_var_) return false;

      if(this.unaided_heading_ != otherMyClass.unaided_heading_) return false;

      if(this.delta_heading_ != otherMyClass.delta_heading_) return false;

      if(this.heading_reset_counter_ != otherMyClass.heading_reset_counter_) return false;

      if(this.heading_good_for_control_ != otherMyClass.heading_good_for_control_) return false;

      if(this.tilt_var_ != otherMyClass.tilt_var_) return false;

      if(this.xy_global_ != otherMyClass.xy_global_) return false;

      if(this.z_global_ != otherMyClass.z_global_) return false;

      if(this.ref_timestamp_ != otherMyClass.ref_timestamp_) return false;

      if(this.ref_lat_ != otherMyClass.ref_lat_) return false;

      if(this.ref_lon_ != otherMyClass.ref_lon_) return false;

      if(this.ref_alt_ != otherMyClass.ref_alt_) return false;

      if(this.dist_bottom_valid_ != otherMyClass.dist_bottom_valid_) return false;

      if(this.dist_bottom_ != otherMyClass.dist_bottom_) return false;

      if(this.dist_bottom_var_ != otherMyClass.dist_bottom_var_) return false;

      if(this.delta_dist_bottom_ != otherMyClass.delta_dist_bottom_) return false;

      if(this.dist_bottom_reset_counter_ != otherMyClass.dist_bottom_reset_counter_) return false;

      if(this.dist_bottom_sensor_bitfield_ != otherMyClass.dist_bottom_sensor_bitfield_) return false;

      if(this.eph_ != otherMyClass.eph_) return false;

      if(this.epv_ != otherMyClass.epv_) return false;

      if(this.evh_ != otherMyClass.evh_) return false;

      if(this.evv_ != otherMyClass.evv_) return false;

      if(this.dead_reckoning_ != otherMyClass.dead_reckoning_) return false;

      if(this.vxy_max_ != otherMyClass.vxy_max_) return false;

      if(this.vz_max_ != otherMyClass.vz_max_) return false;

      if(this.hagl_min_ != otherMyClass.hagl_min_) return false;

      if(this.hagl_max_ != otherMyClass.hagl_max_) return false;


      return true;
   }

   @Override
   public java.lang.String toString()
   {
      StringBuilder builder = new StringBuilder();

      builder.append("VehicleLocalPosition {");
      builder.append("timestamp=");
      builder.append(this.timestamp_);      builder.append(", ");
      builder.append("timestamp_sample=");
      builder.append(this.timestamp_sample_);      builder.append(", ");
      builder.append("xy_valid=");
      builder.append(this.xy_valid_);      builder.append(", ");
      builder.append("z_valid=");
      builder.append(this.z_valid_);      builder.append(", ");
      builder.append("v_xy_valid=");
      builder.append(this.v_xy_valid_);      builder.append(", ");
      builder.append("v_z_valid=");
      builder.append(this.v_z_valid_);      builder.append(", ");
      builder.append("x=");
      builder.append(this.x_);      builder.append(", ");
      builder.append("y=");
      builder.append(this.y_);      builder.append(", ");
      builder.append("z=");
      builder.append(this.z_);      builder.append(", ");
      builder.append("delta_xy=");
      builder.append(java.util.Arrays.toString(this.delta_xy_));      builder.append(", ");
      builder.append("xy_reset_counter=");
      builder.append(this.xy_reset_counter_);      builder.append(", ");
      builder.append("delta_z=");
      builder.append(this.delta_z_);      builder.append(", ");
      builder.append("z_reset_counter=");
      builder.append(this.z_reset_counter_);      builder.append(", ");
      builder.append("vx=");
      builder.append(this.vx_);      builder.append(", ");
      builder.append("vy=");
      builder.append(this.vy_);      builder.append(", ");
      builder.append("vz=");
      builder.append(this.vz_);      builder.append(", ");
      builder.append("z_deriv=");
      builder.append(this.z_deriv_);      builder.append(", ");
      builder.append("delta_vxy=");
      builder.append(java.util.Arrays.toString(this.delta_vxy_));      builder.append(", ");
      builder.append("vxy_reset_counter=");
      builder.append(this.vxy_reset_counter_);      builder.append(", ");
      builder.append("delta_vz=");
      builder.append(this.delta_vz_);      builder.append(", ");
      builder.append("vz_reset_counter=");
      builder.append(this.vz_reset_counter_);      builder.append(", ");
      builder.append("ax=");
      builder.append(this.ax_);      builder.append(", ");
      builder.append("ay=");
      builder.append(this.ay_);      builder.append(", ");
      builder.append("az=");
      builder.append(this.az_);      builder.append(", ");
      builder.append("heading=");
      builder.append(this.heading_);      builder.append(", ");
      builder.append("heading_var=");
      builder.append(this.heading_var_);      builder.append(", ");
      builder.append("unaided_heading=");
      builder.append(this.unaided_heading_);      builder.append(", ");
      builder.append("delta_heading=");
      builder.append(this.delta_heading_);      builder.append(", ");
      builder.append("heading_reset_counter=");
      builder.append(this.heading_reset_counter_);      builder.append(", ");
      builder.append("heading_good_for_control=");
      builder.append(this.heading_good_for_control_);      builder.append(", ");
      builder.append("tilt_var=");
      builder.append(this.tilt_var_);      builder.append(", ");
      builder.append("xy_global=");
      builder.append(this.xy_global_);      builder.append(", ");
      builder.append("z_global=");
      builder.append(this.z_global_);      builder.append(", ");
      builder.append("ref_timestamp=");
      builder.append(this.ref_timestamp_);      builder.append(", ");
      builder.append("ref_lat=");
      builder.append(this.ref_lat_);      builder.append(", ");
      builder.append("ref_lon=");
      builder.append(this.ref_lon_);      builder.append(", ");
      builder.append("ref_alt=");
      builder.append(this.ref_alt_);      builder.append(", ");
      builder.append("dist_bottom_valid=");
      builder.append(this.dist_bottom_valid_);      builder.append(", ");
      builder.append("dist_bottom=");
      builder.append(this.dist_bottom_);      builder.append(", ");
      builder.append("dist_bottom_var=");
      builder.append(this.dist_bottom_var_);      builder.append(", ");
      builder.append("delta_dist_bottom=");
      builder.append(this.delta_dist_bottom_);      builder.append(", ");
      builder.append("dist_bottom_reset_counter=");
      builder.append(this.dist_bottom_reset_counter_);      builder.append(", ");
      builder.append("dist_bottom_sensor_bitfield=");
      builder.append(this.dist_bottom_sensor_bitfield_);      builder.append(", ");
      builder.append("eph=");
      builder.append(this.eph_);      builder.append(", ");
      builder.append("epv=");
      builder.append(this.epv_);      builder.append(", ");
      builder.append("evh=");
      builder.append(this.evh_);      builder.append(", ");
      builder.append("evv=");
      builder.append(this.evv_);      builder.append(", ");
      builder.append("dead_reckoning=");
      builder.append(this.dead_reckoning_);      builder.append(", ");
      builder.append("vxy_max=");
      builder.append(this.vxy_max_);      builder.append(", ");
      builder.append("vz_max=");
      builder.append(this.vz_max_);      builder.append(", ");
      builder.append("hagl_min=");
      builder.append(this.hagl_min_);      builder.append(", ");
      builder.append("hagl_max=");
      builder.append(this.hagl_max_);
      builder.append("}");
      return builder.toString();
   }
}
